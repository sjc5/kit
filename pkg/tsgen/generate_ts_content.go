package tsgen

import (
	"encoding/json"
	"slices"
	"strings"

	"github.com/sjc5/kit/pkg/tsgen/tsgencore"
)

type Opts struct {
	// Path, including filename, where the resulting TypeScript file will be written
	OutPath string

	AdHocTypes []*AdHocType

	ExtraTSCode string

	Collection            []CollectionItem
	CollectionVarName     string // Defaults to "tsgenCollection"
	ExportCollectionArray bool
}

func GenerateTSContent(opts Opts) (string, error) {
	merged := optsToMerged(opts)

	var collection string
	var err error
	hasCollection := len(opts.Collection) > 0

	if hasCollection {
		collection, err = getCollectionStr(opts, merged)
		if err != nil {
			return "", err
		}
	}

	var f strings.Builder

	write(&f, comment("Generated by tsgen. DO NOT EDIT."), 2)

	if hasCollection {
		write(&f, comment("Collection:"), 2)
		write(&f, collection, 2)
	}

	write(&f, comment("Ad Hoc Types:"), 2)
	write(&f, getExports(merged), 2)

	extraTSTrimmed := strings.TrimSpace(opts.ExtraTSCode)
	if extraTSTrimmed != "" {
		write(&f, comment("Extra TS Code:"), 2)
		write(&f, extraTSTrimmed, 1)
	}

	return f.String(), nil
}

// CollectionItem represents a TypeScript object type with arbitrary properties and phantom types.
// It will be added to a constant array in the generated TypeScript file with the name
// assigned to CollectionVarName in Opts.
type CollectionItem struct {
	ArbitraryProperties map[string]any
	PhantomTypes        map[string]AdHocType
}

// Anything you'd like to add to a TypeScript type object,
// other than the phantom types. Value must be JSON-serializable.
type ArbitraryProperty struct {
	Name  string
	Value any
}

type AdHocType = tsgencore.AdHocType

const __commentTemplateNeedsTrim = `/**********************************************************************
/ __REPLACE_ME__
/*********************************************************************/`

var commentTemplate = strings.TrimSpace(__commentTemplateNeedsTrim)

func comment(s string) string {
	return strings.Replace(commentTemplate, "__REPLACE_ME__", s, 1)
}

func optsToMerged(opts Opts) tsgencore.Results {
	var coll_cap int
	if len(opts.Collection) > 0 {
		coll_cap = len(opts.Collection) * len(opts.Collection[0].PhantomTypes)
	}
	adHocTypes := make([]*AdHocType, 0, len(opts.AdHocTypes)+coll_cap)

	for _, adHocType := range opts.AdHocTypes {
		adHocTypes = append(adHocTypes, &AdHocType{
			TypeInstance: adHocType.TypeInstance,
			TSTypeName:   adHocType.TSTypeName,
		})
	}
	for _, item := range opts.Collection {
		for _, phantomType := range item.PhantomTypes {
			adHocTypes = append(adHocTypes, &AdHocType{
				TypeInstance: phantomType.TypeInstance,
				TSTypeName:   phantomType.TSTypeName,
			})
		}
	}

	return tsgencore.ProcessTypes(adHocTypes)
}

func getCollectionStr(opts Opts, merged tsgencore.Results) (string, error) {
	collection := &strings.Builder{}

	if opts.ExportCollectionArray {
		write(collection, "export ")
	}
	write(collection, "const ")
	if opts.CollectionVarName == "" {
		write(collection, "tsgenCollection")
	} else {
		write(collection, opts.CollectionVarName)
	}
	write(collection, " = [", 1)

	itemStrs := make([]string, 0, len(opts.Collection))

	for _, item := range opts.Collection {
		lines := make([]string, 0, len(item.ArbitraryProperties)+len(item.PhantomTypes)+len(item.PhantomTypes))

		for k, v := range item.ArbitraryProperties {
			property := &strings.Builder{}

			write(property, "\t\t")
			write(property, k)
			write(property, ": ")

			formattedValue, err := formatJSValue(v)
			if err != nil {
				return "", err
			}

			write(property, formattedValue)
			write(property, ",", 1)

			lines = append(lines, property.String())
		}

		for propertyName, adHocType := range item.PhantomTypes {
			phantomTypeLine := &strings.Builder{}

			write(phantomTypeLine, "\t\t")
			write(phantomTypeLine, propertyName)
			write(phantomTypeLine, ": ")

			typeInfo := merged.GetTypeInfo(&adHocType)

			switch {
			case typeInfo == nil || typeInfo.IsTSUndefined():
				write(phantomTypeLine, "undefined")
			case typeInfo.IsTSUnknown():
				write(phantomTypeLine, "null as unknown")
			case typeInfo.ResolvedName != "":
				write(phantomTypeLine, "null as unknown as ")
				write(phantomTypeLine, typeInfo.ResolvedName)
			case typeInfo.IsTSBasicType():
				write(phantomTypeLine, "null as unknown as ")
				write(phantomTypeLine, typeInfo.TSStr)
			default:
				write(phantomTypeLine, "undefined")
			}

			write(phantomTypeLine, ",", 1)

			lines = append(lines, phantomTypeLine.String())
		}

		slices.Sort(lines)

		item := &strings.Builder{}

		write(item, "\t{", 1)
		for _, line := range lines {
			write(item, line)
		}
		write(item, "\t}")

		itemStrs = append(itemStrs, item.String())
	}

	slices.Sort(itemStrs)

	for _, itemStr := range itemStrs {
		collection.WriteString(itemStr)
		collection.WriteString(",\n")
	}

	collection.WriteString("] as const;\n\n")

	return strings.TrimSpace(collection.String()), nil
}

func getExports(merged tsgencore.Results) string {
	var exportsLines []string

	for _, t := range merged.Types {
		if t.ResolvedName != "" {
			sb := &strings.Builder{}
			write(sb, "export type ")
			write(sb, t.ResolvedName)
			write(sb, " = ")
			write(sb, t.TSStr)
			write(sb, ";")
			exportsLines = append(exportsLines, sb.String())
		}
	}

	slices.Sort(exportsLines)

	exports := &strings.Builder{}
	for _, line := range exportsLines {
		exports.WriteString(line)
		exports.WriteString("\n\n")
	}

	return strings.TrimSpace(exports.String())
}

func formatJSValue(v any) (string, error) {
	json, err := json.Marshal(v)
	if err != nil {
		return "", err
	}
	return string(json), nil
}

func write(sb *strings.Builder, s string, returns ...int) {
	sb.WriteString(s)
	if len(returns) > 0 {
		for range returns[0] {
			sb.WriteString("\n")
		}
	}
}
